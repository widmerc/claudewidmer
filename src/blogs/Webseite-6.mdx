import RevealBox from "@/app/_components/RevealBox";

export const metadata = {
  title: "Webseite Teil 6 ‚Äì Blog√ºbersicht, Suche & Tag-Filter",
  excerpt: "Wie ich die Blog√ºbersicht mit Tag-Filter, Suche, dynamischer Gruppierung und ansprechender UI umgesetzt habe. Technische Details, Komponenten, Herausforderungen und Learnings.",
  coverImage: "/img/Webseite-6/Titelbild.png",
  date: "2025-06-13T12:00:00.000Z",
  author: {
    name: "Claude Widmer",
    picture: "/img/Webseite-6/Titelbild.png"
  },
  ogImage: {
    url: "/img/Webseite-6/Titelbild.png"
  },
  tags: ["Webseite"]
}

# üóÇÔ∏è Webseite Teil 6 ‚Äì Blog√ºbersicht, Suche & Tag-Filter

In diesem Teil zeige ich, wie ich die Blog√ºbersicht-Seite meiner Webseite technisch und gestalterisch umgesetzt habe. Im Fokus stehen die dynamische Gruppierung nach Hashtags, die Suchfunktion, das Tag-Filtering und die User Experience. Ausserdem gehe ich auf die verwendeten Komponenten, die Datenstruktur und die wichtigsten Learnings ein.

---

## Komponenten-Architektur

Die Blog√ºbersicht besteht aus mehreren modularen Komponenten:

- **BlogSearchAndList**: Zentrale Komponente f√ºr Suche, Tag-Filter und Listen-Rendering
- **PostList**: Zeigt eine Liste von Blogposts zu einem Tag
- **SectionSeparator**: √úberschriften und optische Trennung
- **FadeInOnScroll**: Animierte Einblendung aller Abschnitte
- **BlogPostCard**: Einzelne Blogpost-Vorschau

<RevealBox title="Code: Komponentenstruktur Blog√ºbersicht">
Die folgende Struktur zeigt, wie die wichtigsten Komponenten der Blog√ºbersicht zusammenspielen. Das hilft dir, die Architektur schnell zu verstehen und eigene Anpassungen vorzunehmen.

```tsx
<PageWrapper>
  <SectionSeparator text="Alle Blogs" />
  <FadeInOnScroll>
    <p>Introtext ...</p>
  </FadeInOnScroll>
  <BlogSearchAndList ... />
</PageWrapper>
```

Diese √úbersicht macht es einfach, die Komponenten zu erweitern oder neu zu kombinieren.
</RevealBox>

---

## Suche & Tag-Filter: Funktionsweise

Die Komponente `BlogSearchAndList` erh√§lt alle verf√ºgbaren Tags (`allTags`), eine Map von Tag zu Posts (`tagMap`), sowie optional hervorgehobene Beitr√§ge (`featuredPosts`). Die Suche filtert die Tags live, das Tag-Filtering gruppiert die Posts nach Hashtag.

- **Suche:** Filtert die Tag-Liste nach Nutzereingabe (case-insensitive)
- **Tag-Filter:** Zeigt pro Tag alle zugeh√∂rigen Posts als Gruppe
- **Featured:** Optional k√∂nnen bestimmte Tags/Posts hervorgehoben werden

<RevealBox title="Code: Tag-Suche & Filter (Ausschnitt)">
Hier siehst du, wie die Suche und das Tag-Filtering technisch umgesetzt sind. Das Beispiel zeigt, wie die Tags gefiltert und die zugeh√∂rigen Blogposts gruppiert angezeigt werden.

```tsx
const filteredTags = allTags.filter(tag => tag.toLowerCase().includes(search.toLowerCase()) && tag !== featuredTag);
...
{filteredTags.map((tag) => (
  <FadeInOnScroll key={tag}>
    <h2>#{tag}</h2>
    <PostList posts={tagMap[tag]} />
  </FadeInOnScroll>
))}
```

So kannst du die Filter- und Suchlogik leicht anpassen oder erweitern.
</RevealBox>

---

## Datenstruktur & API

Die Daten f√ºr die √úbersicht werden mit `getAllPosts()` aus `src/lib/api.ts` geladen. Jeder Post enth√§lt Metadaten, Tags, Titel, Bild, etc. Die Gruppierung erfolgt in der √úbersicht dynamisch nach Tags.

<RevealBox title="Code: Tag-Map-Bildung">
Die folgende Logik gruppiert alle Blogposts dynamisch nach ihren Tags. Das ist die Grundlage f√ºr die Tag-√úbersicht und das Filtern in der Blog√ºbersicht.

```ts
const tagMap: Record<string, Post[]> = {};
posts.forEach((post) => {
  post.tags?.forEach((tag) => {
    if (!tagMap[tag]) tagMap[tag] = [];
    tagMap[tag].push(post);
  });
});
```

Diese Information wird dann als Map an die √úbersichtskomponente √ºbergeben und sorgt f√ºr die Gruppierung nach Hashtags.
</RevealBox>

---

## ‚è±Lesezeit (Reading Time)

<RevealBox title="Wie wird die Lesezeit berechnet?">
Die ungef√§hre Lesezeit f√ºr einen Blogpost wird automatisch berechnet. Gez√§hlt werden alle W√∂rter im Beitrag. Zus√§tzlich wird f√ºr jedes Bild (egal ob Markdown oder `<img />`) eine halbe Minute extra gerechnet.

**Code-Beispiel:**
```ts
const words = text.split(/\s+/).filter(Boolean);
const imageCount = ... // Anzahl Bilder im Text
const readingTime = Math.max(1, Math.ceil(words.length / 200) + Math.ceil(imageCount * 0.5));
```

Die berechnete Lesezeit wird dann im Blogpost angezeigt, damit du als Leser:in sofort weisst, wie viel Zeit du ungef√§hr einplanen solltest.
</RevealBox>

---

## UI/UX-Details & Animationen

- **FadeInOnScroll:** Alle Abschnitte und Listen werden animiert eingeblendet
- **Responsives Design:** Die √úbersicht ist auf allen Ger√§ten nutzbar
- **Suchfeld:** Klar zentriert, mit Fokus- und Hover-Effekten
- **Tag-Gruppen:** √úbersichtlich, mit klaren √úberschriften und Abstand
- **Leere Suche:** Zeigt eine freundliche Info, wenn kein Tag gefunden wird

---

## Herausforderungen & Learnings

- **Dynamische Gruppierung:** Die Tag-Map muss bei jedem neuen Post automatisch aktualisiert werden
- **Suche:** Die Filterung muss performant und intuitiv sein
- **Komponenten-Komposition:** Die Trennung von Suche, Tag-Filter und Listen macht die √úbersicht flexibel, aber auch komplexer
- **Datenkonsistenz:** Alle Posts m√ºssen konsistente Metadaten und Tags haben
- **UI-Feedback:** Klare R√ºckmeldung bei leerer Suche verbessert die UX

---

## Ausblick: CMS & WebGIS-Integration

Ein n√§chster, spannender Schritt w√§re die Integration eines CMS (Content Management System), um Blogposts direkt √ºber die Webseite zu erstellen und zu verwalten. Damit k√∂nnten neue Beitr√§ge automatisch generiert und ver√∂ffentlicht werden, ohne den Code oder die Dateien manuell anfassen zu m√ºssen. Geeignete L√∂sungen w√§ren z.B.:

- **Headless CMS** wie Strapi, Sanity, Contentful oder NetlifyCMS
- **Git-basierte CMS** wie TinaCMS oder Forestry, die direkt mit dem Repository arbeiten
- **Eigene Admin-Oberfl√§che**: Ein einfaches Formular, das neue MDX-Dateien erzeugt und per Git speichert

Mit einer solchen L√∂sung k√∂nnten auch Gastbeitr√§ge oder Teamwork einfacher werden. Die Herausforderung ist dabei, die MDX-Features (Komponenten, Metadaten) und die Sicherheit sauber zu integrieren.

---

Ein weiteres, grosses Thema ist die Einbindung von WebGIS-Anwendungen. Beispielsweise k√∂nnten QGIS Web Client Instanzen (wie QWC2 oder QFieldCloud) direkt in die Webseite eingebettet werden, um interaktive Karten, Layer oder Analysen anzuzeigen. Das er√∂ffnet viele M√∂glichkeiten:

- **Interaktive Karten** in Blogposts oder eigenen Seiten
- **Datenvisualisierung** direkt im Browser
- **Integration von Geodiensten** (WMS, WFS, GeoJSON)
- **Verbindung zu eigenen QGIS-Projekten**

Die technische Umsetzung kann z.B. √ºber iFrames, eigene React-Komponenten oder APIs erfolgen. Wichtig ist dabei, Performance, Sicherheit und Usability im Blick zu behalten.

---

## Fazit & Ausblick

Nach sechs Teilen und vielen Stunden Arbeit bin ich mit dem aktuellen Stand meiner Webseite f√ºrs Erste sehr zufrieden. Das Projekt hat mir geholfen, viele neue Skills zu lernen ‚Äì von Next.js √ºber MDX, Animationen mit Framer Motion bis hin zu moderner Komponenten-Architektur und SEO.

Ganz ehrlich: Es war oft auch ziemlich kompliziert. Gerade TypeScript ist f√ºr mich immer noch eine Herausforderung, und ich merke, dass ich da noch viel zu lernen habe. Aber genau das macht so ein Projekt wertvoll ‚Äì man w√§chst an den Aufgaben und versteht mit jedem Schritt mehr.

F√ºr die Zukunft habe ich noch viele Ideen: Mehr Filteroptionen, bessere Performance, vielleicht ein eigenes CMS oder noch mehr interaktive Komponenten. Aber f√ºrs Erste bin ich stolz auf das, was entstanden ist ‚Äì und freue mich, wenn andere davon profitieren k√∂nnen.

---

Claude üë®‚Äçüíª
