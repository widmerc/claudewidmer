import RevealBox from "@/app/_components/RevealBox";

export const metadata = {
  title: "Webseite Teil 5 â€“ Dynamische Blogpost-Sektion",
  excerpt: "Wie ich die Blogpost-Sektion mit dynamischem Routing, Markdown-Rendering, Vorschau-Komponenten und automatischer Slug-Verarbeitung umgesetzt habe.",
  coverImage: "/img/Webseite-5/Titelbild.png",
  date: "2025-04-20T12:00:00.000Z",
  author: {
    name: "Claude Widmer",
    picture: "/img/Webseite-5/Titelbild.png"
  },
  ogImage: {
    url: "/img/Webseite-5/Titelbild.png"
  },
  tags: ["Webseite"]
}

# ğŸ“ Webseite Teil 5 â€“ Dynamische Blogpost-Sektion

Im fÃ¼nften Teil meiner Serie zeige ich im Detail, wie die Blogpost-Sektion meiner Webseite funktioniert. Ziel war es, Markdown-Dateien als Blogposts zu rendern, Slugs automatisch zu verarbeiten, Metadaten auszulesen und fÃ¼r jeden Beitrag eine ansprechende Vorschau zu generieren â€“ alles modular, performant und einfach erweiterbar.

<RevealBox title="Was ist dynamisches Routing? (Einsteiger-ErklÃ¤rung)">

Dynamisches Routing bedeutet, dass Seiten nicht fÃ¼r jeden Blogpost einzeln im Code angelegt werden mÃ¼ssen. Stattdessen gibt es eine Vorlage (z.B. `src/app/blogs/[slug]/page.tsx`), die fÃ¼r jeden Blogpost automatisch verwendet wird â€“ je nachdem, welcher Link aufgerufen wird.

**Beispiel:**
- Die Datei `src/app/blogs/[slug]/page.tsx` ist eine Art Bauplan fÃ¼r alle Blogposts.
- `[slug]` ist ein Platzhalter fÃ¼r den Namen des Blogposts (z.B. `Webseite-1`, `Blog2`, ...).
- Wenn du `/blogs/Webseite-1` aufrufst, sucht Next.js die Datei `Webseite-1.mdx` und zeigt deren Inhalt an.
- Das funktioniert fÃ¼r beliebig viele Blogposts, ohne dass du fÃ¼r jeden eine eigene Seite programmieren musst.

**Vorteile:**
- Du kannst neue Blogposts einfach als `.mdx`-Datei ablegen â€“ sie erscheinen automatisch auf der Webseite.
- Die URL ist immer sauber und lesbar (z.B. `/blogs/MeinNeuerPost`).
- Das System ist flexibel und spart viel Zeit bei der Erweiterung.

**Code-Snippet:**
```tsx
// src/app/blogs/[slug]/page.tsx
export default async function BlogPostPage({ params }) {
  const { slug } = params;
  const post = await getBlogPost(slug);
  // ...
  return <>{post.component}</>;
}
```

</RevealBox>

---

## ğŸ“ Projektstruktur & Ordneraufbau

Die gesamte Blog-Logik ist in einer klaren, modularen Struktur organisiert:

- **`src/blogs/`** â€“ Alle Blogartikel als MDX-Dateien mit Metadaten-Export (z.B. `Webseite-1.mdx`, `Webseite-2.mdx` ...)
- **`src/app/blogs/[slug]/page.tsx`** â€“ Dynamisches Routing: Jede Blogpost-Seite wird statisch generiert und rendert den jeweiligen MDX-Inhalt
- **`src/lib/mdx.ts`** â€“ Hilfsfunktionen zum Auslesen, Parsen und Bereitstellen der Blogposts und Metadaten
- **`src/app/_components/`** â€“ Wiederverwendbare Komponenten wie `BlogPostCard`, `BlogPostSlider`, `CoverImage`, `SectionSeparator`, `FadeInOnScroll`, `Favicon` usw.
- **`public/img/`** â€“ Alle Bilder, die in Blogposts oder Komponenten verwendet werden

---

## ğŸ—‚ï¸ Projektstruktur als Tree-View

Hier die aktuelle Ordnerstruktur meines Projekts als Ãœbersicht (gekÃ¼rzt):

```text
claudewidmer/
â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ favicon/
â”‚   â”œâ”€â”€ img/
â”‚   â”‚   â”œâ”€â”€ Blog1/
â”‚   â”‚   â”œâ”€â”€ Blog1_2/
â”‚   â”‚   â”œâ”€â”€ Blog2/
â”‚   â”‚   â”œâ”€â”€ Blog3/
â”‚   â”‚   â”œâ”€â”€ Webseite-1/
â”‚   â”‚   â”œâ”€â”€ Webseite-2/
â”‚   â”‚   â”œâ”€â”€ Webseite-3/
â”‚   â”‚   â”œâ”€â”€ Webseite-4/
â”‚   â”‚   â”œâ”€â”€ Webseite-5/
â”‚   â”‚   â””â”€â”€ ...
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ _components/
â”‚   â”‚   â”‚   â”œâ”€â”€ AboutMeShort.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ BlogPostCard.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ BlogPostSlider.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ CoverImage.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ FadeInOnScroll.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Favicon.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ ImageGallery.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ RevealBox.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ SectionSeparator.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ SkillCard.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ SkillRadar.tsx
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”œâ”€â”€ blogs/
â”‚   â”‚   â”‚   â””â”€â”€ [slug]/page.tsx
â”‚   â”‚   â”œâ”€â”€ about/page.tsx
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ blogs/
â”‚   â”‚   â”œâ”€â”€ Webseite-1.mdx
â”‚   â”‚   â”œâ”€â”€ Webseite-2.mdx
â”‚   â”‚   â”œâ”€â”€ Webseite-3.mdx
â”‚   â”‚   â”œâ”€â”€ Webseite-4.mdx
â”‚   â”‚   â”œâ”€â”€ Webseite-5.mdx
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â”œâ”€â”€ constants.ts
â”‚   â”‚   â”œâ”€â”€ mdx.ts
â”‚   â”‚   â””â”€â”€ ...
â”œâ”€â”€ package.json
â”œâ”€â”€ next.config.ts
â”œâ”€â”€ tsconfig.json
â””â”€â”€ ...
```

---

## ğŸ—‚ï¸ Wie funktioniert das dynamische Routing?

Jeder Blogpost liegt als `.mdx`-Datei im Verzeichnis `src/blogs/`. Die Datei `src/app/blogs/[slug]/page.tsx` nutzt das Next.js Dynamic Routing: Der `[slug]`-Parameter wird automatisch aus dem Dateinamen generiert. Beispiel: `Webseite-1.mdx` ist unter `/blogs/Webseite-1` erreichbar.

Die Funktion `getBlogPost` (in `mdx.ts`) importiert die MDX-Datei anhand des Slugs, liest die Metadaten aus und gibt die React-Komponente fÃ¼r den Inhalt zurÃ¼ck. Die Funktion `listBlogPosts` listet alle verfÃ¼gbaren Blogposts auf, indem sie das Verzeichnis einliest und fÃ¼r jede Datei die Metadaten extrahiert.

<RevealBox title="Wie wird ein Blogpost geladen und der Slug verarbeitet?">

- Die Funktion `getBlogPost(slug)` lÃ¤dt die passende `.mdx`-Datei anhand des Slugs (also des Namens in der URL).
- Der Slug ist einfach der Dateiname ohne `.mdx`-Endung, z.B. `Webseite-1` fÃ¼r `Webseite-1.mdx`.
- Die Funktion importiert die Datei, liest die Metadaten und gibt die React-Komponente fÃ¼r den Inhalt zurÃ¼ck.

**Code-Beispiel:**
```ts
export const getBlogPost = async (slug: string) => {
  const post = await import(`@/blogs/${slug}.mdx`);
  const data = post.metadata;
  return {
    slug,
    metadata: data,
    component: post.default,
  };
};
```

So wird fÃ¼r jede URL wie `/blogs/Webseite-1` automatisch der richtige Blogpost geladen.

</RevealBox>

---

## ğŸ·ï¸ Beispiel: Metadaten-Export in MDX

Jeder Blogpost beginnt mit einem Metadaten-Export. Diese Daten werden fÃ¼r SEO, OpenGraph, Navigation und Vorschau genutzt.

```mdx
export const metadata = {
  title: "Mein erster Blogpost",
  excerpt: "Kurze Zusammenfassung fÃ¼r die Vorschau.",
  coverImage: "/img/Blog1/Titel.png",
  date: "2025-01-01T12:00:00.000Z",
  author: {
    name: "Claude Widmer",
    picture: "/img/Blog1/Titel.png"
  },
  ogImage: {
    url: "/img/Blog1/Titel.png"
  },
  tags: ["Webseite", "Next.js", "MDX"]
}
```

---

## ğŸ“„ MDX vs. Markdown: Rendering, Komponenten & Probleme

UrsprÃ¼nglich habe ich versucht, reine `.md`-Dateien fÃ¼r Blogposts zu nutzen. Das Markdown-Parsing erfolgte mit `remark` und `rehype`. Das Problem: In klassischen Markdown-Dateien kann kein JavaScript ausgefÃ¼hrt und keine React-Komponenten eingebunden werden. Das bedeutet:

- **Keine Komponenten:** Custom-Komponenten wie `RevealBox`, `ImageGallery` oder animierte Abschnitte sind in `.md` nicht mÃ¶glich.
- **Kein JS/InteraktivitÃ¤t:** Es kÃ¶nnen keine Props, States oder Hooks verwendet werden.
- **EingeschrÃ¤nkte Gestaltung:** Nur Standard-Markdown-Elemente, keine Animationen oder dynamische Inhalte.

Mit **MDX** ist das anders: Hier kann ich Markdown und React-Komponenten beliebig mischen. Das ermÃ¶glicht z.B. RevealBoxen, animierte Abschnitte, Galerien und vieles mehr direkt im Blogpost.
<RevealBox title="Unterschied Markdown (.md) vs. MDX (.mdx)">

- **Markdown (.md):** Nur reiner Text und Standard-Formatierungen (Ãœberschriften, Listen, Links, Bilder). Keine Komponenten, keine Logik, kein JavaScript.
- **MDX (.mdx):** Du kannst Markdown und React-Komponenten mischen. Das heiÃŸt: Interaktive Elemente, eigene Komponenten, Animationen, Galerien usw. direkt im Blogpost.
- **Beispiel:**
```md
# Markdown (.md)
Das ist ein Absatz.

# MDX (.mdx)
Das ist ein Absatz.
<MyComponent prop="Wert" />
```

MDX ist also viel flexibler und moderner fÃ¼r Webseiten mit React/Next.js.

</RevealBox>
---

## ğŸ› ï¸ Technische Details: MDX-Rendering & Komponenten-Mapping

Das MDX-Rendering erfolgt mit `@next/mdx` und eigenen Komponenten-Mappings. In `mdx-components.tsx` werden alle Standard-Elemente (h1-h6, p, ul, li, img, etc.) automatisch mit `FadeInOnScroll` umhÃ¼llt â€“ so werden alle Abschnitte animiert. CodeblÃ¶cke (`pre`) sind davon ausgenommen und werden mit `rehype-pretty-code` fÃ¼r Syntax-Highlighting gestylt.
<RevealBox title="Automatisches Komponenten-Mapping in MDX">

- In der Datei `mdx-components.tsx` wird festgelegt, wie Standard-Elemente (z.B. `h1`, `p`, `ul`, `img`) gerendert werden.
- Dort werden sie automatisch mit Animationen (z.B. `FadeInOnScroll`) umhÃ¼llt.
- So bekommen alle Ãœberschriften, AbsÃ¤tze usw. ein einheitliches, animiertes Aussehen â€“ ohne dass du das in jedem Blogpost einzeln machen musst.

**Code-Beispiel:**
```tsx
export const components = {
  h1: (props) => <FadeInOnScroll><h1 {...props} /></FadeInOnScroll>,
  p: (props) => <FadeInOnScroll><p {...props} /></FadeInOnScroll>,
  ul: (props) => <FadeInOnScroll><ul {...props} /></FadeInOnScroll>,
  pre: (props) => <pre {...props} /> // Kein FadeIn fÃ¼r CodeblÃ¶cke
};
```

Das sorgt fÃ¼r ein konsistentes, modernes Look & Feel in allen Blogposts.

</RevealBox>
---

## âš¡ Performance, SEO & Favicon

- **Statische Generierung:** Alle Blogposts werden bei Build-Time generiert (SSG), was fÃ¼r schnelle Ladezeiten sorgt.
- **SEO:** Die Metadaten werden fÃ¼r Title, Description und Keywords genutzt. OpenGraph- und Twitter-Meta-Tags werden automatisch gesetzt.
- **Favicon:** Ãœber die Komponente `Favicon` wird fÃ¼r jede Seite ein passender Favicon und App-Name gesetzt.
- **Responsives Design:** Alle Komponenten sind mit Tailwind CSS responsiv gestaltet.

---

## ğŸ§© Komponenten im Detail

- **`CoverImage`**: Zeigt das Titelbild eines Blogposts, ist optional verlinkt.
- **`FadeInOnScroll`**: Animiert Abschnitte beim Scrollen mit Framer Motion.
- **`SectionSeparator`**: Trennt Abschnitte optisch und nimmt ein flexibles Spacing entgegen.
- **`ImageGallery`**: FÃ¼r Bildergalerien mit Lightbox und Keyboard-Navigation.
- **`RevealBox`**: Klappbox fÃ¼r technische Details oder Zusatzinfos.
- **`BlogPostCard` & `BlogPostSlider`**: Vorschau und Slider fÃ¼r Blogposts.

Jede Komponente ist so gebaut, dass sie wiederverwendbar und leicht anpassbar ist.

---

## ğŸ”„ Wie geht das HinzufÃ¼gen eines neuen Blogposts?

1. Neue `.mdx`-Datei in `src/blogs/` anlegen (z.B. `MeinNeuerPost.mdx`)
2. Metadaten-Export am Anfang ausfÃ¼llen
3. Inhalt mit Markdown und React-Komponenten schreiben
4. Bild(er) in `public/img/` ablegen und im CoverImage referenzieren
5. Fertig! Der Post erscheint automatisch in der Ãœbersicht und ist unter `/blogs/MeinNeuerPost` erreichbar

---

## ğŸ”œ Wie gehtâ€™s weiter?

Im nÃ¤chsten Teil zeige ich, wie ich die **BlogÃ¼bersicht** gestaltet habe â€“ mit Tag-Filter, Suche und ansprechender Vorschau fÃ¼r alle BeitrÃ¤ge. AuÃŸerdem gehe ich auf die Filter- und Suchlogik sowie die Performance-Optimierung ein.

---

Claude ğŸ‘¨â€ğŸ’»
